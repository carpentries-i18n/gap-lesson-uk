title: "Використання регресійних тестів"
teaching: 40
exercises: 10
questions:
- "Тестова розробка"
objectives:
- "Вміти створювати та запускати тестові файли"
- "Зрозуміти, як розбіжності тестів і регресії під час виконання можна ідентифікувати та інтерпретувати"
- "Зрозуміти, як налаштувати тести для перевірки рандомізованих алгоритмів"
- "Вивчити концепцію 'Зробіть спочатку правильно, а потім швидко'"
keypoints:
- "Легко створити тестовий файл, скопіювавши та вставивши сеанс GAP."
- "Написання хорошого та комплексного набору тестів вимагає певних зусиль."
- "Зробіть спочатку правильно, а потім швидко!"
---

Код `AvgOrdOfGroup` дуже простий, і з ним нічого не може піти 
не так. Перебираючи групу замість створення списку її елементів,
це дозволяє уникнути нестачі пам'яті
(виклик `AsList(SymmetricGroup(11))` вже призводить до перевищення дозволеної
пам'яті). Тим не менш, обчислення все одно займає час, кілька хвилин
необхідні для розрахунку середнього порядку
елемента `SymmetricGroup(11)`. Але принаймні ми впевнені, що це
правильно.

Тепер ми хотіли б написати кращу версію цієї функції, використовуючи деякі теоретичні факти, 
відомі нам із теорії груп. Ми можемо поставити
`avgord.g` під контроль версій, щоб скасувати зміни, якщо потрібно;
ми можемо створити нову функцію, щоб зберегти стару версію й порівняти
результати обох; але це можна зробити ще ефективнішим, якщо ми
використаємо **regression testing**: це термін для тестування на основі
повторних запусків раніше завершених тестів, щоб переконатися, що нові зміни не
вплинуть на їх коректність або не погіршать їх роботу.

Для початку нам потрібно створити **тестовий файл**. Тестовий файл виглядає
точно так само, як сеанс GAP, тому його легко створити, скопіювавши та
вставивши сеанс GAP з усіма підказками, входами та виходами GAP у
текстовий файл (тестовий файл також можна створити з файлу журналу із сеансом
GAP, записаним за допомогою `LogTo`). Під час тестування GAP
виконуватиме всі вхідні дані з тестового файлу, порівнюватиме результати з тими, що містяться в тестовому
файлі, і повідомлятиме про будь-які відмінності.

Тестові файли GAP — це просто текстові файли, але загальноприйнятою практикою є назвати
їх із розширенням `.tst`. Тепер створіть файл `avgord.tst` у поточному каталозі (щоб
вводити повний шлях) з наступним вмістом:

~~~
# тести на середній порядок елемента групи

# група перестановок
gap> S:=SymmetricGroup(9);
Sym( [ 1 .. 9 ] )
gap> AvgOrdOfGroup(S);
3291487/362880
~~~
{: .source}

Як ви бачите, тестовий файл може включати коментарі з певними правилами,
що визначають, де їх можна розміщувати, тому що потрібно мати можливість відрізнити
коментарі в тестовому файлі від вихідних даних GAP, які починаються з `#`. З цією метою,
рядки на початку тестового файлу, які починаються з `#`, і один порожній рядок
разом з одним або декількома рядками, що починаються з `#`, вважаються коментарями.
Усі інші рядки інтерпретуються як вихід GAP із попереднього введення GAP.

Щоб запустити тест, слід використовувати функцію `Test`, як описано в документації
[here](http://www.gap-system.org/Manuals/doc/ref/chap7.html#X87712F9D8732193C).
Наприклад (за умови, що функція `AvgOrdOfGroup` вже завантажена):

~~~
Test("avgord.tst");
~~~
{: .source}

~~~
true
~~~
{: .output}

У цьому випадку `Test` не повідомив про відсутність розбіжностей і повернув `true`, тому
ми робимо висновок, що перевірку пройдено.

Ми не розглядатимемо тут тему написання гарного та комплексного набору тестів,
а також не будемо розглядати різні параметри функції `Test`, що дозволяє нам,
наприклад, ігнорувати відмінності у форматуванні виводу або відображати хід виконання
тесту, як це описано в його документації.

Замість цього ми додамо більше груп до `avgord.tst`, щоб продемонструвати, 
що код також працює з іншими типами груп, і показати різні способи
поєднання команд у тестовому файлі:

~~~
# тести на середній порядок елемента групи

# група перестановок
gap> S:=SymmetricGroup(9);
Sym( [ 1 .. 9 ] )
gap> AvgOrdOfGroup(S);
3291487/362880

# pc група
gap> D:=DihedralGroup(512);
<pc group of size 512 with 9 generators>
gap> AvgOrdOfGroup(D);
44203/512
gap> G:=TrivialGroup();; # suppress output
gap> AvgOrdOfGroup(G);
1

# fp група
gap> F:=FreeGroup("a","b");
<free group on the generators [ a, b ]>
gap> G:=F/ParseRelators(GeneratorsOfGroup(F),"a^8=b^2=1, b^-1ab=a^-1");
<fp group on the generators [ a, b ]>
gap> IsFinite(G);
true
gap> AvgOrdOfGroup(G);
59/16

# скінченна група матриць над цілими числами
gap> AvgOrdOfGroup( Group( [[0,-1],[1,0]] ) );
11/4

# група матриць над скінченним полем
gap> AvgOrdOfGroup(SL(2,5));
221/40
~~~
{: .source}

Давайте ще раз протестуємо розширену версію тесту та перевіримо, чи вона працює:

~~~
Test("avgord.tst");
~~~
{: .source}

~~~
true
~~~
{: .output}

Зараз ми будемо працювати над кращою реалізацією. Звичайно, порядок елемента
є інваріантом класу спряженості елементів групи, тому нам потрібно лише знати порядки класів спряженості елементів та їх представників. 
Наступний код, який ми додаємо до `avgord.g`, зчитує GAP і перевизначає
`AvgOrdOfGroup` без синтаксичних помилок:

~~~
AvgOrdOfGroup := function(G)
local cc, sum, c;
cc:=ConjugacyClasses(G);
sum:=0;
for c in cc do
  sum := sum + Order( Representative(c) ) * Size(cc);
od;
return sum/Size(G);
end;
~~~
{: .source}

але коли ми запускаємо тест, ось сюрприз!

~~~
Read("avgord.g");
Test("avgord.tst");
~~~
{: .source}

~~~
########> Diff in avgord.tst, line 6:
# Ввід:
AvgOrdOfGroup(S);
# Очікуваний вивід:
3291487/362880
# Але знайдено:
11/672
########
########> Diff in avgord.tst, line 12:
# Ввід:
AvgOrdOfGroup(D);
# Очікуваний вивід:
44203/512
# Але знайдено:
2862481/512
########
########> Diff in avgord.tst, line 23:
# Ввід:
AvgOrdOfGroup(G);
# Очікуваний вивід:
59/16
# Але знайдено:
189/16
########
########> Diff in avgord.tst, line 29:
# Ввід:
AvgOrdOfGroup(SL(2,5));
# Очікуваний вивід:
221/40
# Але знайдено:
69/20
########
false
~~~
{: .output}

Дійсно, ми допустили помилку (навмисно) і замінили `Size(c)` на `Size(cc)`.
Правильний варіант курсу має виглядати так:

~~~
AvgOrdOfGroup := function(G)
local cc, sum, c;
cc:=ConjugacyClasses(G);
sum:=0;
for c in cc do
  sum := sum + Order( Representative(c) ) * Size(c);
od;
return sum/Size(G);
end;
~~~
{: .source}

Тепер ми виправимо це в `avgord.g`, прочитаємо та протестуємо його знову, щоб перевірити,
 чи тести виконуються правильно.

~~~
Read("avgord.g");
Test("avgord.tst");
~~~
{: .source}

~~~
true
~~~
{: .output}

Таким чином, підхід «Зробіть спочатку правильно, а потім швидко» допоміг виявити помилку
відразу після її появи.

