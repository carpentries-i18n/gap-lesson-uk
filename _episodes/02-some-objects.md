---
title: "Ще декілька об’єктів GAP"
teaching: 15
exercises: 5
questions:
- "Подальші приклади об'єктів і операцій з ними"
objectives:
- "Перегляньте приклади типів, які вбудовані в GAP, але можуть бути відсутні в інших системах"
- "Подивіться приклади арифметики списку"
keypoints:
- "GAP має безліч різноманітних безпосередніх, позиційних і складових об'єктів."
- "Арифметика списків є дуже гнучкою та потужною."
- "Такі об’єкти, як списки та записи, підходять для зберігання структурованих і пов’язаних даних."
---

Наразі ми познайомилися з трьома типами GAP:

* такі прості об'єкти, як цілі числа, раціональні числа, булеві значення, перестановки;

* такі складені об'єкти, як _lists_;

* такі об’єкти з більш складним внутрішнім представленням, як групи.

У цьому розділі ми продемонструємо деякі інші приклади базових об’єктів,
які існують у GAP (система розширювана, тому можна вводити нові типи
об’єктів, але це виходить за рамки цього уроку!).

Деякі інші прості об'єкти - це floats, cyclotomics and finite field elements:

~~~
1.15; Float(1232/3456567);
~~~
{: .source}

~~~
1.15
0.000356423
~~~
{: .output}

~~~
E(4); E(4)^2; E(6);
~~~
{: .source}

~~~
E(4)
-1
-E(3)^2
~~~
{: .output}

~~~
AsList(GF(2)); Z(5); Z(5)^4;
~~~
{: .source}

~~~
[ 0*Z(2), Z(2)^0 ]
Z(5)
Z(5)^0
~~~
{: .output}

Ви вже знаєте про списки.
Іншим типом складених об’єктів є **записи**. У той час як список містить субоб’єкти, проіндексовані
за їх позиціями в списку, запис містить субоб’єкти, які називаються _компонентами
запису_, які індексуються за своїми іменами. Elements of a record are accessed with `.`

~~~
date:= rec(year:= 2015, month:= "Nov", day:= 17);
~~~
{: .source}

~~~
rec( day := 17, month := "Nov", year := 2015 )
~~~
{: .output}

~~~
date.year;
~~~
{: .source}

~~~
2015
~~~
{: .output}

~~~
date.time:= rec(hour:= 14, minute:= 55, second:= 12);
~~~
{: .source}

~~~
rec( hour := 14, minute := 55, second := 12 )
~~~
{: .output}

~~~
date;
~~~
{: .source}

~~~
rec( day := 17, month := "Nov",
  time := rec( hour := 14, minute := 55, second := 12 ), year := 2015 )
~~~
{: .output}

~~~
RecNames(date);
~~~
{: .source}

~~~
[ "time", "year", "month", "day" ]
~~~
{: .output}

Далі є **рядки** та **символи**. Хоча GAP спеціально друкує
рядки, насправді рядок — це лише список символів, і будь-яка
функція, яка приймає список, також прийматиме рядок. Навпаки, символи
є простими об’єктами, такими як цілі числа.

~~~
gap> w:="supercalifragilisticexpialidocious"; Length(w);
~~~
{: .source}

~~~
"supercalifragilisticexpialidocious"
34
~~~
{: .output}

Рядки позначаються подвійними лапками, а символи одинарними.

~~~
gap> "s" in w; 's' in w; IsSubset(w,"s");  IsSubset(w,['s','f']); ['c','a','t'] = "cat";
~~~
{: .source}

~~~
false
true
true
true
true
~~~
{: .output}

Зауважте, що

~~~
gap> PositionSublist(w,"sf"); PositionSublist(w,"fr");
~~~
{: .source}

~~~
fail
10
~~~
{: .output}

Будьте обережні! Деякі операції можуть створити новий список, тоді як інші є
деструктивними. Наприклад:

~~~
gap> SortedList(w); w;
~~~
{: .source}

~~~
"aaacccdeefgiiiiiiillloopprrssstuux"
"supercalifragilisticexpialidocious"
~~~
{: .output}

але

~~~
gap> Sort(w); w;
~~~
{: .source}

~~~
"aaacccdeefgiiiiiiillloopprrssstuux"
~~~
{: .output}

Яка літера зустрічається у "supercalifragilisticexpialidocious" найчастіше?

~~~
gap> c := Collected(w);
~~~
{: .source}

~~~
[ [ 'a', 3 ], [ 'c', 3 ], [ 'd', 1 ], [ 'e', 2 ], [ 'f', 1 ], [ 'g', 1 ],
  [ 'i', 7 ], [ 'l', 3 ], [ 'o', 2 ], [ 'p', 2 ], [ 'r', 2 ], [ 's', 3 ],
  [ 't', 1 ], [ 'u', 2 ], [ 'x', 1 ] ]
~~~
{: .output}

~~~
gap> k := Maximum( List( c, v -> v[2] ) ); Filtered( c, v -> v[2] = 7 );
~~~
{: .source}

~~~
7
[ [ 'i', 7 ] ]
~~~
{: .output}

> ## Пошук найпоширеніших букв у списку за допомогою лише одного проходу
>
> Команда
>
> `k := Maximum( List( c, v -> v[2] ) ); Filtered( c, v -> v[2] = 7 );`
>
> двічі перебирає список `c` (у `List` і `Filtered`), а
> також перебирає інший список такої ж довжини, що й `c ` у виклику
 > `Maximum`. Якщо список довгий, це призведе до певного зниження
продуктивності та пам’яті. Спробуйте написати код, який знаходить літери, які найчастіше трапляються
> в `c`, не створюючи проміжного списку.
{: .challenge}

